// --- Globals ---
let systemState = {};
let providerModels = {};
const BACKEND_URL = 'http://1227.0.0.1:8000';

// --- Initialization ---
document.addEventListener('DOMContentLoaded', () => {
    initializeState();
    initializeUI();
    initializeEventListeners();
});

function initializeState() {
    systemState = {
        aiConfig: {
            provider: 'google',
            model: 'gemini-1.5-pro-latest',
            isConnected: false
        },
        verificationState: {
            isRunning: false,
            forceStop: false,
            currentIteration: 0,
            consecutivePasses: 0,
            maxIterations: 8,
            requiredPasses: 3,
        },
        solutions: [],
        finalSolution: null, // To store the final verified solution
        errorReports: [],
        pythonResults: [],
        actionPlans: []
    };

    providerModels = {
        google: [{ value: 'gemini-1.5-pro', text: 'Gemini 1.5 Pro' }],
        openai: [{ value: 'gpt-4', text: 'OpenAI GPT-4' }],
        deepseek: [
            { value: 'deepseek-chat', text: 'DeepSeek Chat' },
            { value: 'deepseek-reasoner', text: 'DeepSeek Reasoner' }
        ]
    };
}

function initializeUI() {
    updateModelOptions();
    updateConnectionStatus();
    const stepsContainer = document.querySelector('.verification-steps');
    const steps = [
        { id: 1, label: "初始解/修正" },
        { id: 2, label: "自我改进" },
        { id: 3, label: "AI 验证" },
        { id: 4, label: "Python 验证" },
        { id: 5, label: "AI 审查" },
        { id: 6, label: "最终决策" }
    ];
    stepsContainer.innerHTML = steps.map(s => `
        <div class="verification-step" id="main-step-${s.id}">
            <div class="step-number">${s.id}</div>
            <div class="step-label">${s.label}</div>
        </div>
    `).join('');
    // Set default values from state to UI
    document.getElementById('max-iterations').value = systemState.verificationState.maxIterations;
    document.getElementById('consecutive-passes-config').value = systemState.verificationState.requiredPasses;
}

function initializeEventListeners() {
    document.getElementById('solve-button').addEventListener('click', startRigorousVerification);
    document.getElementById('stop-button').addEventListener('click', stopVerification);
    document.getElementById('test-ai-btn').addEventListener('click', testAIConnection);
    document.getElementById('test-connection-btn').addEventListener('click', testBackendConnection);
    document.getElementById('save-all-btn').addEventListener('click', saveAllFiles);
    document.getElementById('export-data-btn').addEventListener('click', exportVerificationData);
    document.getElementById('generate-pdf-btn').addEventListener('click', generatePdfReport);
    document.getElementById('api-provider').addEventListener('change', updateModelOptions);
    document.getElementById('model-version').addEventListener('change', () => {
        systemState.aiConfig.model = document.getElementById('model-version').value;
    });
}

// --- UI Update Functions ---
function updateConnectionStatus() {
    const statusIndicator = document.getElementById('ai-connection-status');
    if (systemState.aiConfig.isConnected) {
        statusIndicator.className = 'status-indicator status-connected';
    } else {
        statusIndicator.className = 'status-indicator status-disconnected';
    }
}

function updateModelOptions() {
    const provider = document.getElementById('api-provider').value;
    const models = providerModels[provider] || [];
    const modelSelect = document.getElementById('model-version');
    modelSelect.innerHTML = models.map(m => `<option value="${m.value}">${m.text}</option>`).join('');
    systemState.aiConfig.provider = provider;
    if (models.length > 0) {
        systemState.aiConfig.model = models[0].value;
    }
}

function updateMainStepStatus(step, status) {
    const stepElement = document.getElementById(`main-step-${step}`);
    if (stepElement) {
        stepElement.className = `verification-step ${status}`;
    }
}

function displayResult(title, content, type = '') {
    const container = document.getElementById('results-container');
    const resultSection = document.createElement('div');
    resultSection.className = `result-section ${type}`;
    resultSection.innerHTML = `
        <div class="result-header">${title}</div>
        <div class="result-content">${markdownToHtml(content)}</div>
    `;
    container.appendChild(resultSection);
    if (window.MathJax) {
        window.MathJax.typesetPromise([resultSection]);
    }
}

function updateErrorLogDisplay(errors) {
    const errorLogElement = document.getElementById('error-log-content');
    const errorLogContainer = errorLogElement.parentElement;

    if (errors && errors.length > 0) {
        const formattedErrors = errors.map((error, index) => {
            return `<strong>第 ${index + 1} 轮错误:</strong><br>${markdownToHtml(error)}`;
        }).join('<hr style="margin: 10px 0;">');
        errorLogElement.innerHTML = formattedErrors;
        errorLogContainer.style.display = 'block';
    } else {
        errorLogElement.textContent = '暂无错误';
        errorLogContainer.style.display = 'none';
    }
}

function updateFailureReasonDisplay(reason) {
    const reasonContainer = document.getElementById('failure-reason-display');
    const reasonContent = document.getElementById('failure-reason-content');
    if (reason) {
        reasonContent.innerHTML = markdownToHtml(reason);
        reasonContainer.style.display = 'block';
    } else {
        reasonContainer.style.display = 'none';
    }
}


function showNotification(message, type = 'success', duration = 3000) {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `<span>${message}</span>`;
    document.body.appendChild(notification);
    setTimeout(() => {
        notification.remove();
    }, duration);
}

function updateStatusDisplay() {
    document.getElementById('current-iteration').textContent = systemState.verificationState.currentIteration;
    document.getElementById('consecutive-passes').textContent = systemState.verificationState.consecutivePasses;
    document.getElementById('total-errors').textContent = systemState.verificationState.totalErrors;
    document.getElementById('python-validations').textContent = systemState.verificationState.pythonValidations;
}


// --- Core Logic ---
async function startRigorousVerification() {
    const problem = document.getElementById('problem-input').value;
    if (!problem) {
        showNotification('请输入数学问题', 'error');
        return;
    }

    // Reset state and apply UI settings
    initializeState();
    systemState.verificationState.maxIterations = parseInt(document.getElementById('max-iterations').value, 10);
    systemState.verificationState.requiredPasses = parseInt(document.getElementById('consecutive-passes-config').value, 10);
    const rigor = document.getElementById('verification-rigor').value;

    document.getElementById('results-container').innerHTML = '';
    updateErrorLogDisplay(null);
    updateFailureReasonDisplay(null);
    systemState.verificationState.isRunning = true;
    systemState.verificationState.forceStop = false;
    
    const solveButton = document.getElementById('solve-button');
    const stopButton = document.getElementById('stop-button');
    solveButton.disabled = true;
    stopButton.style.display = 'block';

    let currentSolution = "";
    let lastErrorReport = "";

    while (systemState.verificationState.currentIteration < systemState.verificationState.maxIterations &&
           systemState.verificationState.consecutivePasses < systemState.verificationState.requiredPasses &&
           !systemState.verificationState.forceStop) {
        
        systemState.verificationState.currentIteration++;
        updateStatusDisplay();

        try {
            // Step 1: Generate Initial Solution or Corrected Solution
            updateMainStepStatus(1, 'active');
            let solvePrompt = `Problem: ${problem}\n\n`;
            if (lastErrorReport) {
                solvePrompt += `Based on the following error report, provide a corrected and improved solution:\n${lastErrorReport}\n\nSolution:`;
            } else {
                solvePrompt += `Provide a detailed step-by-step solution:`;
            }
            currentSolution = await callAI('initial_solution', { problem: problem, prompt: solvePrompt, solution: currentSolution, rigor: rigor });
            systemState.solutions.push(currentSolution);
            displayResult(`第 ${systemState.verificationState.currentIteration} 轮 - AI解答`, currentSolution, 'solution');
            updateMainStepStatus(1, 'completed');

            // Step 2: Self-Improvement
            updateMainStepStatus(2, 'active');
            const improvementPrompt = `Review the following solution for the problem "${problem}". Identify potential flaws, missing steps, or areas for improvement. Then, provide a refined version.\n\nSolution:\n${currentSolution}`;
            let improvedSolution = await callAI('self_improve_solution', { problem: problem, prompt: improvementPrompt, solution: currentSolution, rigor: rigor });
            
            if (!improvedSolution.toLowerCase().includes('solution') && !improvedSolution.toLowerCase().includes('proof')) {
                improvedSolution = currentSolution;
            }
            currentSolution = improvedSolution;
            systemState.solutions[systemState.solutions.length - 1] = currentSolution;

            displayResult(`第 ${systemState.verificationState.currentIteration} 轮 - 自我改进`, currentSolution, 'solution');
            updateMainStepStatus(2, 'completed');

            // Step 3: AI Verification
            updateMainStepStatus(3, 'active');
            const verificationPrompt = `Problem: "${problem}". Verify the following solution and provide a detailed error report. If no errors are found, state "Verification passed."\n\nSolution:\n${currentSolution}`;
            const errorReport = await callAI('verify', { problem: problem, prompt: verificationPrompt, solution: currentSolution, rigor: rigor });
            displayResult(`第 ${systemState.verificationState.currentIteration} 轮 - AI验证报告`, errorReport, 'verification');
            lastErrorReport = errorReport;
            
            updateMainStepStatus(3, 'completed');

            // Step 4: Python Validation
            updateMainStepStatus(4, 'active');
            const pythonCode = extractPythonCode(currentSolution);
            if (pythonCode) {
                const pythonResult = await executePythonCode(pythonCode);
                systemState.pythonResults.push(pythonResult);
                systemState.verificationState.pythonValidations++;
                if (pythonResult.success) {
                    displayResult(`第 ${systemState.verificationState.currentIteration} 轮 - Python验证结果`, `<pre>${pythonResult.output}</pre>`, 'python-success');
                } else {
                    displayResult(`第 ${systemState.verificationState.currentIteration} 轮 - Python执行失败`, `<pre>${pythonResult.error}</pre>`, 'python-error');
                }
            } else {
                 displayResult(`第 ${systemState.verificationState.currentIteration} 轮 - Python验证`, "解答中未找到可执行的Python代码。", 'python-info');
            }
            updateMainStepStatus(4, 'completed');

            // Step 5 & 6: Review and Decision
            updateMainStepStatus(5, 'active');
            updateMainStepStatus(6, 'active');
            if (!errorReport.toLowerCase().includes('error') && !errorReport.toLowerCase().includes('mistake')) {
                systemState.verificationState.consecutivePasses++;
                showNotification(`第 ${systemState.verificationState.currentIteration} 轮验证通过!`, 'success');
            } else {
                systemState.verificationState.consecutivePasses = 0;
                systemState.verificationState.totalErrors++;
                systemState.errorReports.push(errorReport);
                showNotification(`第 ${systemState.verificationState.currentIteration} 轮发现问题`, 'warning');
                updateErrorLogDisplay(systemState.errorReports);
            }
            updateStatusDisplay();
            updateMainStepStatus(5, 'completed');
            updateMainStepStatus(6, 'completed');

        } catch (error) {
            showNotification(`第 ${systemState.verificationState.currentIteration} 轮出现严重错误: ${error.message}`, 'error');
            systemState.verificationState.forceStop = true;
        }
    }

    // Final wrap-up
    if (systemState.verificationState.consecutivePasses >= systemState.verificationState.requiredPasses) {
        systemState.finalSolution = currentSolution;
        displayResult('最终结论', '验证成功! 解答已连续通过所需次数的验证。', 'final-success');
    } else if (systemState.verificationState.forceStop) {
        displayResult('最终结论', '验证被手动或因错误而终止。', 'final-stopped');
    } else {
        displayResult('最终结论', '验证结束。未达到连续通过要求。', 'final-fail');
        updateFailureReasonDisplay(lastErrorReport);
    }

    systemState.verificationState.isRunning = false;
    solveButton.disabled = false;
    stopButton.style.display = 'none';
}


function stopVerification() {
    if (systemState.verificationState.isRunning) {
        systemState.verificationState.forceStop = true;
        showNotification('停止信号已发送，将在当前步骤完成后终止。', 'warning');
    }
}

async function testAIConnection() {
    const statusIndicator = document.getElementById('ai-connection-status');
    statusIndicator.className = 'status-indicator status-testing';
    
    try {
        const response = await callAI('generate_python_solution', { 
            problem: "This is a test problem.",
            prompt: "Say 'Hello, World!'",
            code: "",
            solution: "This is a test."
        });
        if (response) {
            systemState.aiConfig.isConnected = true;
            showNotification('AI 连接成功!', 'success');
        } else {
            systemState.aiConfig.isConnected = false;
            throw new Error('API响应无效');
        }
    } catch (error) {
        systemState.aiConfig.isConnected = false;
        console.error('AI Connection Test Failed:', error);
        showNotification(`AI 连接失败: ${error.message}`, 'error');
    } finally {
        updateConnectionStatus();
    }
}

async function testBackendConnection() {
    const provider = document.getElementById('api-provider').value;
    displayResult('后端连接测试', `正在测试到 ${provider} 的连接...`, 'info');
    try {
        const response = await fetch(`${BACKEND_URL}/api/test-connection`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ provider })
        });
        const result = await response.json();
        if (response.ok) {
            displayResult(`后端连接测试: ${provider}`, `连接成功: ${result.message}`, 'python-success');
        } else {
            throw new Error(result.detail || '未知错误');
        }
    } catch (error) {
        displayResult(`后端连接测试: ${provider}`, `连接失败: ${error.message}`, 'python-error');
    }
}


// --- API Call Functions ---
async function callAI(task, data) {
    try {
        const response = await fetch(`${BACKEND_URL}/api/call-ai`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                provider: systemState.aiConfig.provider,
                model: systemState.aiConfig.model,
                task: task,
                data: data
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || `API请求失败: ${response.status}`);
        }

        const dataResponse = await response.json();
        return dataResponse.response;
    } catch (error) {
        console.error("AI call failed:", error);
        throw error;
    }
}

async function executePythonCode(code) {
    try {
        const response = await fetch(`${BACKEND_URL}/api/execute-python`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ code: code })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.detail || `Python execution failed: ${response.status}`);
        }
        
        return await response.json();

    } catch (error) {
        console.error("Python execution failed:", error);
        return { success: false, error: error.message || String(error), output: '', image: null };
    }
}

// --- File Handling & Reporting ---
async function generatePdfReport() {
    const problem = document.getElementById('problem-input').value;
    if (!problem || systemState.solutions.length === 0) {
        showNotification('没有可用于生成报告的内容。请先运行验证流程。', 'warning');
        return;
    }

    showNotification('正在生成PDF报告，请稍候...', 'info');

    let requestBody;
    const isSuccess = !!systemState.finalSolution;

    if (isSuccess) {
        requestBody = {
            problem: problem,
            solution: systemState.finalSolution,
            status: "success",
            provider: systemState.aiConfig.provider,
            model: systemState.aiConfig.model
        };
    } else {
        requestBody = {
            problem: problem,
            solution: systemState.solutions[systemState.solutions.length - 1], // Last attempted solution
            status: "failed",
            error_reports: systemState.errorReports,
            provider: systemState.aiConfig.provider,
            model: systemState.aiConfig.model
        };
    }

    try {
        const response = await fetch(`${BACKEND_URL}/api/generate-latex-pdf`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const reportType = isSuccess ? "Success_Report" : "Failure_Analysis";
            a.download = `数学验证报告_${reportType}_${timestamp}.pdf`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            showNotification('PDF报告已成功生成并开始下载！', 'success');
        } else {
            const errorData = await response.json();
            console.error('PDF Generation Failed:', errorData.detail);
            displayResult('PDF 生成失败', `后端返回错误: <pre>${errorData.detail}</pre>`, 'final-fail');
            showNotification('PDF报告生成失败，请查看结果区域的错误日志。', 'error', 5000);
        }
    } catch (error) {
        console.error('Failed to generate PDF report:', error);
        showNotification(`生成PDF报告时发生网络错误: ${error.message}`, 'error');
    }
}


async function saveAllFiles() {
    if (typeof JSZip === 'undefined') {
        showNotification('ZIP library not loaded.', 'error');
        return;
    }
    if (systemState.solutions.length === 0) {
        showNotification('没有可保存的验证数据。', 'warning');
        return;
    }

    const zip = new JSZip();
    const problem = document.getElementById('problem-input').value;

    zip.file("problem.txt", problem);

    let manifest = `数学验证全流程报告\n========================\n`;
    manifest += `问题: ${problem.substring(0, 50)}...\n`;
    manifest += `验证时间: ${new Date().toLocaleString()}\n`;
    manifest += `总迭代次数: ${systemState.verificationState.currentIteration}\n`;
    manifest += `最终状态: ${systemState.verificationState.consecutivePasses >= systemState.verificationState.requiredPasses ? "验证成功" : "未完全验证"}\n\n`;
    manifest += `文件结构:\n`;

    for (let i = 0; i < systemState.verificationState.currentIteration; i++) {
        const iterationFolder = zip.folder(`iteration-${i + 1}`);
        if (systemState.solutions[i]) {
            iterationFolder.file("solution.md", systemState.solutions[i]);
            manifest += `- iteration-${i + 1}/solution.md\n`;
        }
        if (systemState.errorReports[i]) {
            iterationFolder.file("error-report.md", systemState.errorReports[i]);
            manifest += `- iteration-${i + 1}/error-report.md\n`;
        }
        if (systemState.pythonResults[i]) {
            const presult = systemState.pythonResults[i];
            const code = presult.code || "No code executed.";
            const output = presult.success ? presult.output : presult.error;
            iterationFolder.file("verification-code.py", code);
            iterationFolder.file("execution-result.txt", output);
            manifest += `- iteration-${i + 1}/verification-code.py\n`;
            manifest += `- iteration-${i + 1}/execution-result.txt\n`;
        }
    }
    zip.file("manifest.txt", manifest);

    try {
        const content = await zip.generateAsync({ type: "blob" });
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `数学验证全流程_${timestamp}.zip`;
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        showNotification('所有文件已成功打包并开始下载!', 'success');
    } catch (error) {
        console.error("Failed to generate zip file:", error);
        showNotification('创建ZIP文件失败。', 'error');
    }
}

function exportVerificationData() {
    showNotification('数据导出功能正在实现中...', 'warning');
}

// --- Utils ---
function markdownToHtml(text) {
    if (!text) return '';
    // Simple markdown to HTML for demonstration
    return text
        .replace(/```python\n([\s\S]*?)\n```/g, '<pre><code class="language-python">$1</code></pre>')
        .replace(/\n/g, '<br>');
}

function extractPythonCode(text) {
    if (typeof text !== 'string') {
        return null;
    }
    const codeMatch = text.match(/```python\n([\s\S]*?)\n```/);
    return codeMatch ? codeMatch[1] : null;
}


// --- Placeholder for future functionality ---
async function generateReport() {
    showNotification('报告生成功能正在开发中...', 'info');
}